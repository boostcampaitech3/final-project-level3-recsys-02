apiVersion: v1
kind: Service
metadata:
  name: api-server-svc
  labels:
    app: api-server
spec:
  selector:
    app: api-server
  ports:
  - name: http
    port: 8000
    protocol: TCP
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: api-server-cm
  labels:
    app: api-server
data:
  requirements.txt: |
    fastapi==0.75.0
    pydantic==1.9.0
    uvicorn==0.17.6
    nats-py==2.1.2
    slowapi==0.1.5
    Jinja2==3.1.2
  __init__.py: |

  broker.py: |
      import json
      import nats
      from nats.errors import TimeoutError
      from nats.js.errors import BadRequestError
      from nats.js.errors import NotFoundError
      from nats.js.errors import KeyDeletedError
      
      class Broker:
          def __init__(self, host: str, logger):
              """
              Nats client í´ëž˜ìŠ¤ìž…ë‹ˆë‹¤.
              createStream() ê³¼ subscribe() ì—ì„œ ì¸ìžë¡œ ì „ë‹¬ë˜ëŠ” stream ì€ ë…¼ë¦¬ì ìœ¼ë¡œ ë¶„ë¦¬ëœ ê³µê°„ì´ê³ 
              subject ê°€ ë©”ì‹œì§€ íë¼ê³  ìƒê°í•˜ì‹œë©´ ë©ë‹ˆë‹¤.

              :param host: a kubernetes service IP:port string
              """
              self.logger = logger
              self.host = host
              self.__client = None
              self.__jetstream = None
              self.__subscriber = None
              self.__bucket = None

          async def connect(self):
              """
              Jetstream íŒŒì´ì¬ API ê°€ ë¹„ë™ê¸° í´ë¼ì´ì–¸íŠ¸ë§Œ ì§€ì›í•˜ë¯€ë¡œ ë¹„ë™ê¸° ì ‘ì†
              __init__() ì—ì„œ í˜¸ì¶œ ë¶ˆê°€ëŠ¥í•©ë‹ˆë‹¤.
              FastAPI ê°€ uvloop ì„ ë ˆë²„ë¦¬ì§•í•˜ë¯€ë¡œ íŒŒì´ì¬ asyncio event loop ì—ì„œ í˜¸ì¶œí•˜ì§€ ë§ˆì‹œê³ 
              ì•„ëž˜ ì˜ˆì‹œì™€ ê°™ì´ í˜¸ì¶œí•´ì£¼ì„¸ìš”.

              # ì˜ˆì‹œ
              @app.on_event('startup')
              async def init():
                  await broker.connect()

              :return:
              """
              try:
                  self.__client = await nats.connect(self.host)
                  self.__jetstream = self.__client.jetstream()
                  self.logger.formatter('Successfully connected to the Nats server.')
              except TimeoutError:
                  raise Exception(self.logger.formatter('Timed out on connecting to the Nats server.'))

          async def createStream(self, stream: str, subjects: list):
              """
              stream ì´ë¦„ê³¼ subjects ë“¤ì„ ìƒì„±í•©ë‹ˆë‹¤.

              :param stream: a stream name to which subject belongs
              :param subjects: a list of subjects on which messages persist
              :return:
              """
              try:
                  response = await self.__jetstream.add_stream(name=stream, subjects=subjects)
                  self.logger.formatter(response)
              except TimeoutError:
                  raise Exception(self.logger.formatter('Timed out on creating a stream'))
              except BadRequestError:
                  raise Exception(self.logger.formatter('Stream name already exists.'))

          async def removeStream(self, stream: str):
              """
              stream ì„ ì‚­ì œí•©ë‹ˆë‹¤.

              :param stream:
              :return:
              """
              try:
                  response = await self.__jetstream.delete_stream(stream)
                  self.logger.formatter(response)
              except TimeoutError:
                  raise Exception(self.logger.formattter('Timed out on removing a stream'))

          async def subscribe(self, durable: str, stream: str, subject: str):
              """
              subscribe() ì´í›„ pull() ê°€ëŠ¥í•©ë‹ˆë‹¤.

              :param durable: a consumer identifier with which the Nats server identifies the queue
              :param stream: a stream name to which the subject belongs
              :param subject: a subject to subscribe to
              :return:
              """
              try:
                  self.__subscriber = await self.__jetstream.pull_subscribe(subject, durable, stream)
                  self.logger.formatter(await self.__subscriber.consumer_info())
              except TimeoutError:
                  raise Exception(self.logger.formatter('Timed out on a subscription.'))

          async def publish(
                  self,
                  subject: str,
                  payload: bytes,
                  timeout: float,
                  stream: str,
                  headers: dict,
          ) -> bool:
              """
              client hashing ì„ í†µí•´ ë‚˜ì˜¨ key ê°’ì„ key-value ìŠ¤í† ì–´ì— ìƒì„±í•˜ê³  Nats server ì— ë°ì´í„°ë¥¼ publish í•©ë‹ˆë‹¤.
              Payload agnostic => ë°ì´í„° íƒ€ìž…ì— ìƒê´€ ì—†ì´ publish

              :param subject: a subject to publish to
              :param payload: data bytes
              :param timeout: timeout
              :param stream: a stream name to which the subject belongs
              :param headers: a json header for additional information
              :return: True if the publishing succeeded | False if timed out on publishing
              """
              try:
                  await self.createKey(key=headers.get('key'), value=b'')
                  await self.__jetstream.publish(subject, payload, timeout, stream, headers)
                  return True
              except TimeoutError:
                  return False

          async def pull(self, batchSize: int, timeout: float = 5.0) -> list:
              """
              ìºì‹±ëœ Payload ë¥¼ ë°°ì¹˜ ì‚¬ì´ì¦ˆë§Œí¼ ê°€ì ¸ì˜µë‹ˆë‹¤.

              :param batchSize: determines the size of a list to pull
              :param timeout: timeout
              :return: a list of user request to be inferred
              """
              try:
                  pulled = await self.__subscriber.fetch(batchSize, timeout)
                  batch = []
                  for message in pulled:
                      data = json.loads(message.data)
                      batch.append((message.headers, data))
                      await message.ack()
                  return batch
              except TimeoutError:
                  pass

          async def createBucket(self, name: str):
              """
              Bucket ìƒì„±í•©ë‹ˆë‹¤.

              :param name: a bucket name to be created
              :return:
              """
              try:
                  self.__bucket = await self.__jetstream.create_key_value(bucket=name)
              except TimeoutError:
                  raise Exception(self.logger.formatter('Timed out on creating a bucket.'))

          async def fetchResult(self, key: str) -> object:
              """
              key ì—ì„œ ê°’ ê°€ì ¸ì˜¤ê¸°

              :param key:
              :return:
              """
              try:
                  result = await self.__bucket.get(key=key)
                  return result.value
              except NotFoundError:
                  return None
              except KeyDeletedError:
                  return None

          async def createKey(self, key: str, value: bytes):
              """
              Bucket ì— key ìƒì„±í•˜ê³  value ì¶”ê°€
              :param key:
              :param value: bytes
              :return: 
              """
              try:
                  return await self.__bucket.put(key=key, value=value)
              except:
                  self.logger.formatter('Timed out on creating and assigning a key-value item.')
                  return None

          async def removeKey(self, key: str):
              """
              Bucket ì—ì„œ key ì‚­ì œ
              :param key:
              :return:
              """
              try:
                  await self.__bucket.delete(key)
              except:
                  self.logger.formatter('Timed out on removing a key-value item.')
  events.py: |
      import asyncio
      from datetime import datetime
      import time
      from typing import Callable
      
      
      class ServerLog:
          @staticmethod
          def formatter(message: str):
              """
              Pod console ì— ë©”ì‹œì§€ í‘œì‹œí•  ë•Œ í¬ë§·í•´ì£¼ëŠ” wrapper function
              :param message: log string
              :return:
              """
              formatted = datetime.now().strftime('[%Y/%D, %H:%M:%S] : {log}').format(log=message)
              print(formatted)
              return formatted
  main.py: |
      import asyncio
      from fastapi import FastAPI
      from fastapi import Request
      from fastapi.templating import Jinja2Templates
      import hashlib
      from broker import Broker
      from events import ServerLog
      import time

      # Rate Limiting for QOS
      from slowapi import Limiter, _rate_limit_exceeded_handler
      from slowapi.util import get_remote_address
      from slowapi.errors import RateLimitExceeded

      """
      slowapi => Throttling (rate limit ì„¤ì •) ìš”ì²­ ìˆ˜ ì œí•œì„ ìœ„í•´ in-memory storage ì— ìš”ì²­ì„ ìºì‹±í•˜ëŠ” êµ¬í˜„ì²´
      rate limits string format
      [count] [per|/] [n (optional)] [second|minute|hour|day|month|year]
      ì¶œì²˜ : "https://limits.readthedocs.io/en/stable/quickstart.html#rate-limit-string-notation"
      """

      # global
      HOST = '10.107.112.241:4222'  # Kubernetes Service IP for the broker
      limiter = Limiter(key_func=get_remote_address)
      app = FastAPI()
      templates = Jinja2Templates(directory='/app/templates')
      app.state.limiter = limiter
      app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)
      logger = ServerLog()
      broker = Broker(HOST, logger)

      # subjects for debugging only
      testSubjects = [
          'input',
      ]


      async def getResult(key: str, timeout: float, interval: float) -> object:
          timeElapsed = 0.0
          timeStarted = time.perf_counter()
          while timeElapsed <= timeout:
              result = await broker.fetchResult(key)
              if result:
                  await broker.removeKey(key)
                  return result
              timeElapsed += (time.perf_counter() - timeStarted)
              await asyncio.sleep(interval)
          await broker.removeKey(key)
          return None


      async def clientBasedHashing(request: Request):
          if request is not None:
              client = str(dict(request)['client']).encode()
              payload = await request.body()
              key = hashlib.sha256(client + payload).hexdigest()
              return payload, key


      @app.on_event('startup')
      async def init():
          await broker.connect()
          # await broker.removeStream('inference')
          await broker.createStream('inference', testSubjects)
          await broker.createBucket('inference')


      @app.get('/')
      @limiter.limit('3/second')
      async def main(request: Request):
          return templates.TemplateResponse('map.html', {'request': request})


      @app.post('/inference')
      @limiter.limit('3/second')
      async def inference(request: Request):
          payload, key = await clientBasedHashing(request)
          ack = await broker.publish('input', payload, 5.0, 'inference', {'key': key})
          if ack:
              result = await getResult(key, 5.0, 0.5)
              if result:
                  return {'status': True, 'data': result}
              else:
                  return {'status': False, 'data': 'Unable to fetch the result.'}
          else:
              return {'status': False, 'data': 'Timed out on publishing a message.'}
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: templates-cm
  labels:
    app: api-server
data:
  map.html: |
      <!DOCTYPE html>
      <head>    
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />

              <script>
                  L_NO_TOUCH = false;
                  L_DISABLE_3D = false;
              </script>

          <style>html, body {width: 100%;height: 100%;margin: 0;padding: 0;}</style>
          <style>#map {position:absolute;top:0;bottom:0;right:0;left:0;}</style>
          <script src="https://cdn.jsdelivr.net/npm/leaflet@1.6.0/dist/leaflet.js"></script>
          <script src="https://code.jquery.com/jquery-1.12.4.min.js"></script>
          <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js"></script>
          <script src="https://cdnjs.cloudflare.com/ajax/libs/Leaflet.awesome-markers/2.0.2/leaflet.awesome-markers.js"></script>
          <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.6.0/dist/leaflet.css"/>
          <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css"/>
          <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap-theme.min.css"/>
          <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css"/>
          <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Leaflet.awesome-markers/2.0.2/leaflet.awesome-markers.css"/>
          <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/python-visualization/folium/folium/templates/leaflet.awesome.rotate.min.css"/>

                  <meta name="viewport" content="width=device-width,
                      initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
                  <style>
                      body{
                          background-color: #FFFFFF;
                      }

                      .title{
                          position: relative;
                          width: 95.0%;
                          height: 4.0%;
                          margin: 0.5% 0.0% 0.5% 2.0%;
                          color: #7E6499;
                          font-weight: bold
                      }

                      #map_5d0c3cd8484d4f8a1642815f065b1271 {
                          position: relative;
                          width: 100.0%;
                          height: 55.0%;
                          margin: 0.5% 0.0% 0.5% 0.0%;
                      }

                      .button {
                          position: relative;
                          width: 96.0%;
                          margin: auto;
                      }

                      .inference {
                          position: relative;
                          width: 80.0%;
                          height: 10.0%;
                          background: linear-gradient(to bottom right, #DB8258 5%, #B06BAB 70%, #7E6499 100%);
                          border-style: none;
                          border-radius: 10px;
                          margin: 1.0% 0.5% 1.0% 0.5%;
                          padding: 1.0% 1.0% 1.0% 1.0%;
                          float: left;
                          font-size: 36px;
                      }

                      .inference:hover {
                          background: #DB8258;
                      }

                      .gps {
                          position: relative;
                          width: 15.0%;
                          height: 10.0%;
                          background: linear-gradient(to bottom right, #DB8258 5%, #B06BAB 70%, #7E6499 100%);
                          border-style: none;
                          border-radius: 10px;
                          margin: 1.0% 1.5% 1.0% 1.5%;
                          padding: 1.0% 1.0% 1.0% 1.0%;
                          float: right;
                          font-size: 36px;
                      }

                      .gps:hover {
                          background: #DB8258;
                      }

                      .placeInfo {
                          position: relative;
                          width: 95.0%;
                          height: 35.0%;
                          overflow: scroll;
                          margin: auto;
                      }

                      .placeInfo::-webkit-scrollbar  {
                          background-color: white;
                          border-radius: 10px;

                      }

                      .placeInfo::-webkit-scrollbar-thumb  {
                          background-color: #f2e6ff;
                          border-radius: 10px;
                      }

                      .placeDetails {
                          position: relative;
                          width: 88%;
                          background-color: #ffffff;
                          border-style: none;
                          border-radius: 10px;
                          margin: 0.5% 1.0% 0.5% 0.5%;
                          padding: 0.5% 0.5% 0.5% 0.5%;
                          text-align: center;
                          font-size: 2.5em;
                          display: inline-block;
                      }

                      .placeDetails:active {
                          background: #B06BAB;
                      }

                      .like {
                          position: relative;
                          width: 10.0%;
                          float: right;
                          background: linear-gradient(to bottom, #B06BAB 30%, #7E6499 100%);
                          border-style: none;
                          border-radius: 10px;
                          margin: 0.5% 0.5% 0.5% 0.0%;
                          padding: 0.5% 0.5% 0.5% 0.5%;
                          font-size: 2.5em;
                          display: inline-block;                }

                      .like:active {
                          background: #DB8258;
                      }

                      .borders {
                          position: relative;
                          width: 100.0%;
                          border-style: none none solid none;
                          border-color: #f2f0f5;
                          border-width: 0.01em;
                      }

                  </style>
      </head>
      <body>
                  <h2 class="title">ðŸ”Ž ìž¥ì†Œ ì¶”ì²œ</h2>
                  <div class="folium-map" id="map_5d0c3cd8484d4f8a1642815f065b1271" ></div>

                  <div class="button">
                      <button class="inference" onclick="inference()"> ì¶”ì²œ </button>
                      <button class="gps" onclick="gps()"> ë‚´ ìœ„ì¹˜ </button>
                  </div>


                  <div class="placeInfo"></div>
      </body>
      <script>

                  var mapapi = L.map(
                      "map_5d0c3cd8484d4f8a1642815f065b1271",
                      {
                          center: [37.476559992, 126.981638570],
                          crs: L.CRS.EPSG3857,
                          zoom: 17,
                          zoomControl: true,
                          preferCanvas: false,
                      }
                  );

                  var states = {
                      layers: {}, //fetch í•´ì„œ ë°›ì€ ê²ƒ ë“¤ì–´ì˜´
                      preferencesList: new Array(), // ì¢‹ì•„ìš” ìˆœì„œëŒ€ë¡œ ì €ìž¥
                      preferences: new Set(),
                  };

                  // current location marker
                  var currentMarker = L.marker(
                      [37.476559992, 126.981638570]
                  ).addTo(mapapi);

                  var tile_layer_0a4787307dbd68cc33a93ae4432df960 = L.tileLayer(
                      "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
                      {"attribution": "Data by \u0026copy; \u003ca href=\"http://openstreetmap.org\"\u003eOpenStreetMap\u003c/a\u003e, under \u003ca href=\"http://www.openstreetmap.org/copyright\"\u003eODbL\u003c/a\u003e.", "detectRetina": false, "maxNativeZoom": 18, "maxZoom": 18, "minZoom": 0, "noWrap": false, "opacity": 1, "subdomains": "abc", "tms": false}
                  ).addTo(mapapi);

                  // move marker
                  mapapi.addEventListener("move", function(){
                      var center = mapapi.getCenter();
                      mapapi.removeLayer(currentMarker)
                      currentMarker = L.marker([center.lat, center.lng]).addTo(mapapi);
                  })

                  // remove previously drawn markers and divs
                  function removeLayers() {
                      var isEmpty = Object.keys(states.layers).length === 0;

                      if (!isEmpty) {
                          for ([key, value] of Object.entries(states.layers)) {
                              for (obj of value) {
                                  obj.remove();
                              }
                              delete key;
                          }
                      }
                  }

                  function addMarker(key, value) {
                      // add a marker
                      var marker = L.marker([value.latitude, value.longitude]).addTo(mapapi);

                      // a popup bound to the marker
                      var popup = L.popup().setContent(key);
                      marker.bindPopup(popup);

                      return marker;
                  }

                  function addDetails(key, value) {
                      var placeInfo = document.getElementsByClassName("placeInfo")[0];

                      // add details.
                      var placeDetails = document.createElement("div");
                      placeDetails.setAttribute("class", "placeDetails");
                      placeDetails.setAttribute("id", key);
                      placeDetails.appendChild(document.createTextNode(value.name));
                      placeDetails.onclick = function() {
                          states.layers[this.id][0].openPopup();
                      }
                      placeInfo.appendChild(placeDetails);


                      // add a like button.
                      var like = document.createElement("button");
                      like.setAttribute("class", "like");
                      like.setAttribute("id", key);
                      like.appendChild(document.createTextNode("ðŸ¤"));
                      like.onclick = function() {
                          if(!states.preferences.has(this.id)){
                              if(states.preferences.size == 5){
                                  var deleteValue = states.preferencesList[0];
                                  states.preferencesList.shift();
                                  states.preferences.delete(deleteValue);
                              }
                              states.preferences.add(this.id);
                              states.preferencesList.push(this.id);
                          }
                          console.log(states.preferencesList)
                          console.log(states.preferences);
                      }
                      placeInfo.appendChild(like);

                      // add border line
                      var borders = document.createElement("div");
                      borders.setAttribute("class", "borders");
                      borders.setAttribute("id", key);
                      placeInfo.appendChild(borders);

                      return {placeDetails, like, borders};
                  }

                  function dataHandler(data, center) {
                      if (data.status) {
                          // remove previous markers.
                          removeLayers();

                          // parse json data and add layers.
                          const places = JSON.parse(data.data);
                          for (const [key, value] of Object.entries(places)) {
                              // add a layer
                              var marker = addMarker(key, value);
                              var details = addDetails(key, value);
                              states.layers[key] = [marker, details.placeDetails, details.like, details.borders];
                          }
                      }
                      else {
                          alert(data.data);
                      }
                  }

                  function inference() {
                      var center = mapapi.getCenter();
                      mapapi.removeLayer(currentMarker)
                      currentMarker = L.marker([center.lat, center.lng]).addTo(mapapi);
                      fetch(
                          "http://61.254.240.172:30000/inference", {
                              method: "POST",
                              body: JSON.stringify({
                                  "latitude": center.lat,
                                  "longitude": center.lng,
                                  "preferences": Array.from(states.preferences),
                              })
                          })
                          .then((response) => response.json())
                          .then((data) => {
                              dataHandler(data, center);
                          })
                          .catch((error) => {
                              alert(error);
                          });

                      // initialize
                      $('div').scrollTop(0);

                  }

                  // get current location success
                  function getLocation(position) {
                      // get current location and move map
                      const lat  = position.coords.latitude;
                      const lng = position.coords.longitude;
                      mapapi.setView([lat, lng], 17)

                  }

                  // get current location
                  function gps() {
                      if (navigator.geolocation) {
                          mapapi.removeLayer(currentMarker)
                          navigator.geolocation.getCurrentPosition(getLocation);
                      }
                      else {
                          console.log("you can't get your current location")
                      }
                  }

      </script>
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: api-server
  labels:
    app: api-server
spec:
  selector:
    matchLabels:
      app: api-server
  replicas: 1
  strategy:
    type: RollingUpdate
  template:
    metadata:
      labels:
        app: api-server
    spec:
      volumes:
      - name: api-server-volume
        configMap:
          name: api-server-cm
      - name: templates-volume
        configMap:
          name: templates-cm
      containers:
      - name: api-server
        image: python:3.8
        imagePullPolicy: IfNotPresent
        ports:
        - name: http
          containerPort: 8000
        - name: tcp-client
          containerPort: 4222
        volumeMounts:
        - name: api-server-volume
          mountPath: /app
        - name: templates-volume
          mountPath: /app/templates
        command:
        - "/bin/bash"
        - "-c"
        - "pip install -r /app/requirements.txt;
          uvicorn main:app --app-dir /app --proxy-headers --host 0.0.0.0 --port 8000"
      terminationGracePeriodSeconds: 30